C++与C的区别  （c++实质上包含了整个的c语言）
			c++是强类型语言，对类型检查比较严格；
			c++增加了很多 的内容
				支持面向对象
				支持泛型变成 
				支持异常
				支持运算符重载
			差别：
			1：源文件的扩展 名是 .cpp  .cxx  .cc  .C
			2: 不再使用c中的头文件，c++的头文件几乎都不带.h 的
			3：所有的标准的类似及函数 变量 对象都是存放在命名空间（名字空间）std当中
				
			未使用命名空间时可以用 std:: 来代替；
			
			4:  c++当中 变量 可驻在任意地方定义，要使用的时候定义都可以
				for(int i=0; i....)
				
			
   1 头文件，C++ 新标准基本没.h文件，但是兼容老标准；
   2 输入输出
		C语言里面输出使用的是printf
		c++ 使用cin ，cout
	
	C++ 中的结构体，联合  枚举
	   1：c++ 中的结构体与c语言的结构 体使用差不多
	        但c++多出来一些功能：c++里面是可以放函数的
	        c++中的结构体在声明或者定义的时候不需要 加上struct
	   		c语言： struct stu{}; struct stu a;
	   		c++：  struct stu{};  stu b;
		
		c++下的结构体和class差别
			如果 说使用struct的时候，里面不写限定权限的关键字的话，系统 默认里 
			面的的所有成员以及成员函数都是public
			如果说class里面没有写的话默认的是将所有的内容设定为私有！
		
		如果说是多文件结构 test.h  test.cpp  main.cpp
			test.h里面包含的内容是一个类的定义 
			test.cpp 里面实质上是对.h文件里面类的实现
			main.cpp里面是包含有主函数的文件
			多文件 结构 的编译 过程不能直接g++带有主函数的.cpp文件 会导致找不到
			相关的函数
			正确使用过程：
				1：先编译相应 的.h文件 的实现文件（也就是非主函数 文件 的其
				他.cpp文件）只编译－c选项生成.o文件
				2：将生成的.o文件跟带有主函数的.cppy文件一同编译生成可执行文件即
					可
				
		
	
	   2:   联合 一致 定义 变量 的时候  前面的union可以省略
	   3：  枚举   几乎一致
	   
	 c++的函数
	 	c++中的函数的参数它是严格匹配的 空参数代表 没有任何参数 c++不支持隐式声
	 		明
	 		函数可以实现重载－－也就是允许 相同名称的函数
	 		函数的重载
	 			在同一个作用域呆以允许名称 相同，但是他的函数 类型以及参数个数可
	 			以不同
	 		C语言的函数在编译之后函数名还是原来 的函数名
	 		c++函数在编译之后
	 		     例：int fun(int a)
	 		      编译之后在内存里面：_int _fun_int
	 		      如果说需要 在c++程序 当中把相关的函数编译 按照 C语言的形式来
	 		      编译的话，需要在前面加上extern 告诉编译器这个函数 按照c语言的
	 		      形式编译
	 		C++函数支持默认值
	 		c++当中多出来一个部分   内联函数 需要 使用关键字
	 			inline
	 			内联函数的特点是 实质上是使用宏来定义的
	 			如果一个函数申明为内联函数的话在编译 的过程之中会直接将函数的代码
	 			之后拷贝到相应调用函数的位置
	 			如果说是普通 函数 的话
	 				当调用 相应 函数 的时候 会通过 函数 名（也就是函数 的地址）
	 				找到相关的函数执行
	 		c++当中的内存分配
	 			之前c语言当中的分配是使用malloc free
	 			C++中使用的是new delete;
	 			
	 			
	 				int* a=new int;//使用方式不保证里面的值为0;
	 				int* p=new int[5]//在堆中分配5个int大小的空间
	 				int* b=new int(100);在堆中分配内存空间大小为int的空间，
	 						然后初始值为100；
	 				 
	    c++中的引用 
	    	引用时基于指针的封装
	    	c++中可以随意 使用指针相应 的内容
	    	引用实质上是给变量起别名
	    	引用是不占内存空间的！
	    	
	    使用：
	    	int& b=a;
	    	
	   指针与引用差别：
	   	指针存在空的指针，但不存 在空的引用，
	   	定义引用的时候，就必须对引用进行初始化，否则会报错！
	   	指针 可以改变指向但引用不可以！
	   	引用实质上是用指针来实现的！
	   	
C++是一门对象的语言
	面向对象编程
		对象－
		
		类跟对象 
		怎样去定义一个类
			1： 可以直接 使用struct来定义
			2：直接 使用c++特有的class（类）
				注意在c＋＋中结构体与类几乎没有区别；
				public; 出现这个关键字后面的成员变量 以及成员函数都 是该类型的
					共有成员
					如果 说是公有成员的话，可以在任意地方使用！
				private;
					私有
						只能在类的内部使用不能在外面 使用对象，私有成员编译器会
						报错
				protected;	
					以上三种都可以在结构 体以及类当中使用每次 可以使用单个或者 
					多个
	
		类的构成 ---构造函数
						实质上是在创建对象的时候会自动调用 的函数如果说定义类的
						时候没有添加构造 函数系统 会默认 给你添加 
							可以管理对象以及初始化，赋值
					析构函数
						是在对象释放之前自动调用 的函数如果没有定义系统 会添加默
						认 的函数
					成员变量
					成员函数
	   
	   
	   
	   
补充：c++的新的变量类型 bool 布尔值类型	   
	   
	
	
	c语言的字符串
		char* b ="1234" ; char a[15];
	c++的字符串
		单独封装了一个类型string (本质上是一个类)
		字符串可以直接用等号了！
		
		
初始化参数列表；
	int* a=new int(4);
	
			Node(const int& d)
		{
			data=d;
			next=NULL;
		}		
		
		与下面的这种方法等同：
			Node(const int& d):
			
			
	this是当前对象指针
		this指针
		
		
		
		返回值可以直接 返回 当前对象指针
			return this;
			return* this;
			const 对象和const成员函数
			凡是参数上面加了const就一定是输入参数，而且参数是不能被修通行证的
			析构函数  构造函数
			函数重载：允许统一个作用域里面存在同名称的函数 只不过参数以及参数类
				型不一样即可；
			构造函数允许被重载
			
			在堆中的构造以及释放对象
			使用new delete相对malloc和free而言
				差别 new会调用相应的类的构造函数,delete 会调用相应 的析构函数
			拷贝构造函数－－
			 	用一个类的对象 初始化另一个对象成为缺省成员初始化
			 	缺 省成员初始化对于类的正确 行为 是不合适的
	
	拷贝构造 函数
		运算符重载
			系统提供的运算符号只支持基础变量不支持自定义类型所以需要将相应的运算
			符重载 之后才能支持
			重载操作符函数使类的对象能够用在运算表达式当中，而且使用方式跟不同变
			量的使用方式相同 
			
	一致string类定义如下；
	class String
		{
			public:
				String(const char* str=NULL);//通用构造函数
				String(const string& a);//拷贝构造函数
				~String();
				String& operator=(const String& a); //运算符重载
		}
		

     在c++里面 把所有的数据以及函数封装起来组成一个类
	友元函数：通过函数或者操作符号把函数申明或者变量申明成类的友元，一个类要以让该函数或者操作符号，或者变量拥有访问非公有成员的权利
	申明友元，使用关键字frend  他只能是在类里面定义；
	因为友元不是类的成员，所以他不受public等的影响；
	
	封装 继承 多态
		封装：面向对象的程序设计当中，使用public等关键字功能修饰一些变量以及函
			  数隐藏起来，一般在写代码的时候会根据具体情况适当的提供一些公开的函
			  数（接口），来操作相应的隐藏数据，以及函数这种行为就是封装；
		
		继承：是一种代码利用的方式 ，可以根据现有的类的数据以及行为来创建新的类
				并添加新的数据以及方法
			子类（派生类）和父类（基类）
			继承方式有三种：
			public
			protected
			private
			
		多态：多种形态，是允许将父类对象设置为一个或者 多个它的子类对象相等的
			的技术，
			实际上，调用的的函数为子类对象的函数，实现对于同样的函数
			每个函数实现不同效应
			多态属性，可以使用一个基类类型的指针来引用不同类型子类的对象；	
		
			
	
	构造函数析构函数--先调用基类的构造然后再调用子类的构造 ，释放的时候先调用
			子类的析构，再调用基类的析构
		
		虚继承：通过关键字virtaul修正一个基类的声明，带有虚拟继承的类，那这个类
			叫做虚拟派生类，通过虚继承可以避免重复继承的问题；
			加上virtual 就表示允许其子类对其进行修改！
		
	
	
类的大小实例：
		
#include<iostream>
using namespace std;
class test
{
	virtual void fun()
	{
		cout<<"123424"<<endl;
	}
	virtual void fun()
	{
		cout<<"123424"<<endl;
	}
};
struct a{};
int main()
{
	cout<<sizeof(a)<<endl;
	cout<<sizeof(test)<<endl;
	 //有函数没有实际变量还是 1；加上virtual会加上一个虚表指针, 大小就是4个字节；
	 //然后再增加一个virtual,大小还是4个字节，因为它只会生成一个虚表指针；
	return 0;
}
	

	   
	   函数的重写 override
	   	  要求 函数名相同，参数列表相同，返回类型相同 
	   函数的覆盖   overload
	   		类似于同名称的全局变量跟局部变量
	 虚函数 在类当中定义的虚函数的放，说明子类继承它的时候可以对该函数进行重写
	 		需要输入关键字virtual
	 		
纯虚函数：virtual void fun()=0;
	永远不需要实例化的类应该定义成抽象类，一个虚函数不需要或者不能写出任何实现
		的时候可以定义为虚函数
	   存在纯虚函数的类是抽象类
	   抽象类是不允许实例化的，抽象类除了不能实例化以外，其他功能和普通类完全相
	   同
	   
	   
练习：
	写一个工人，方法是挣钱，-- 把这个可以设置为抽象 类
	类 教师 销售 商人， CEO
	
	
	
	

模板 
	函数模板
	类模板 
	模板提升代码的复用性－－
	Template
	T add(T a ,T b)
	{
		return a+b;
	}
	
	类模板的定义方式 
		template<class T>
		class 类名
			{
				T data;
			};
	类模板的使用
		类名＜类型名＞对象名称（）；
		
	函数模板
		函数模板的定义方式
			template<class 参数类型1，class 参数类型2；........>
			返回值类型 函数模板名（形参列表）	
	         {
	         	
	         }
	        使用方式与类相同；
template<class T,class T1,class T2>
T2 add(T a , T1 b)
{
	return a+b;
};
int main()
{
	cout<<add<int ,int,int>(1,2)<<endl;
	return 0;
}
	
	
C++标准模板库: 通用模板＋算法的一个集合；
 STL(C++标准模板库):
 	有10个主要的容器：lvector(向量)   链表（list）  双端队列（dequeue）
 					stack(堆栈)    队列queue   优先队列  
 					映射map    集合  多重映射   多重集合
 			
 			容器的共同特点：
 				全都支持操作符，一个容器可以作为一个整体给其他的整体赋值
 				两个相等“＝＝”必须满足条件：两个容器的类型相同，而且两个
 				容器的元素个数相同，像个容器之间对应的元素相同
 					大小比较：“＜”小于符号的判别方式
 					两个容器的类型必须相同，一个容器里面的元素跟另外一个容器
 					相对应的元素比较都要比它小才能判定大小！
		  
		 当一个类型的对象被插入到一个容 器当中的时候，那这个容器实际存储的是这个
		 对象的一份拷贝，而不是对象本身！实质调用的是拷贝构造函数！
		 
		 	STL:有三大核心部分：容器，算法，迭代器（相当于指针）
		 	容器（container）：数据在内存中组织的方法
		 	算法(algorithm)：是应用在容器上的各种各样的操作方法
		 	迭代器（iterator）:类似于指针，一旦选定一种容器类型和数据行为
		 						本质上就是一种泛化指针；
		 					分类：
		 						输入迭代器
		 						输出迭代器
		 						双向迭代器
		 						前向迭代器
		 						随机访问迭代器
		 						流迭代器
		 						
	1：向量（vector）:(动态数组)
	向量的几本通用算法，begin()  end()   push back()    front()
	   
	   
C++异常处理（c中没有）
	异常：程序 中执行过程中的一些不正常的现象！
	异常的关键字：exception  它本身是一个对象！
	异常的工作原理：
		程序员在写代码的时候出现意外的地方自动产生一个异常 然后抛出一个异常对象
		对象被传递到负责处理异常的地方
		由负责异常处理的代码进行统一 的异常处理
	异常抛出格式：
		抛出：throw 异常名称 
		处理：
			try
			{
				//把有可能发生异常的代码放到这里
			}catch(异常1)
			{
				处理代码
			}catch(异常2)
			{
				处理代码
			}
		每个catch只能处理一种类型的异常catch会一次执行
		catch（...)捕获任意类型的异常，但是不能判断是什么 类型的异常
		了，一般是把它放在最后一个catch语句块
			异常处理完毕之后，不会回到发生异常的地方，产生异常之后，程序会立即
			跳转到最近的一层不会异常的语句，如果当前没有捕获语句，或者 说没有匹
			配的catch的话，那么程序会直接跳出当前的函数 回到调用 的地方
				如果说跳到main函数还是没有处理异常，那程序就会终止！
			
			
			
			
			
			
			
			
			
			
			
			
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   		
