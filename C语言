c语言的结构
必须包含入口函数main函数
int main()
｛
  return 0;
｝

printf(); 实质上是包含在标准头文件stdio.h
#include<stdio.h>
将文件插入到当前位置
\n 换行
#预处理行
如果说引入的是系统提供 的内容使用<>,如是使用自己定义的文件，使用""

int printf(const char  
*format,//格式占位符号 
...)//可变长参数 
｛
｝
printf("hello 09\n");
c语言结束的标志是；
c语言是支持一行上面写多行语句的
写程序 的时候要加上相应的注释
注释有两种方式
1：单行注释//
2：多行注释/*     */
 
\-----续行符
c 程序的一个编译步骤
   		1 编译
       gcc -c 
   		  生成一个.o的目标 文件
                
                2连接
                   生成一个可执行文件
自己定义生成可执行文件 的名称
	gcc hello.c -o+名称

数据的表现形式
二进制 1   0

int 4字节
char 字符类型     1字节

在计算机内部所有的内容 都 是用二进制位来表示的
0000 0001  权重位
0000 0010   

表示 负数 用最高位 做符号位
负数用补码来表示
              补码用原码取反加1
例子：
－1
0000 0001  原码
1111  1110  反码
1111   1111  补码




float  4字节
0  0000000     00000000     00000000    00000000
第一位 （最左边）符号位
左边的八位   阶码
剩下的是尾数




c语言变量类型
      	char 字符类型
			float 浮点型    都 可以使用  %f %g
			double 双精度的小数
 			int    整型   %d
             ％x是打印十六进制
   	       ％o是八进制
         long int
         long long  
         unsigned int   char
         short int






变量是什么 ？
               变量的定义
      int a； //定义一个整型变量 ，变量的名称是a
      int a ;如果只定义没有赋值没有初始化，a的值就是一个脏数据；

 		字符变量的赋值必须加上单引号;


常量   不可改变的变量
int a=13；  a是变量，13 是常量
用const修饰变量，该变量就是只读的！（常量）
使用宏定义的方式来定义常量 （＃define pi 3.14）

两者的差别在于，
宏定义不会做类型检查，是直接 采用字符串替换，会在预处理期间 将所有的PI替换成3.14
const修饰变量是只读变量，在编译的过程中会做类型安全检查。


sizeof 系统保留关键字，不是函数（本质上是一个操作符）
                功能：计算变量在内存中所占用的大小
                             同样可计算类型的大小








地址类型变量       指针变量

指针 存放的是地址
int* a；//定义了一个存放地址类型的变量（定义了一个指针变量  变量存放int类型的地址）
定义了一个指向int类型的指针变量 
char* a
凡是指针变量 sizeof出来都是4个字节



基础变量类型相当于饮料


char* b=NULL; 定义一个char类型的指针变量，初始化为空
＆取地址符
b＝＆b1，把b1的地址赋值给b



指针常量  ( 翻译： 指针的常量)
常量指针（翻译： 常量的指针）
const int b =13;
const int c=13;
int d=15;

int* a=&b; //a是指向int类型的指针；
const int a=10; //int类型的变量a它的值是不可以改变的
（常量的指针）const int* a=NULl; //a是指向整型常量的指针

（指针中的常量）int* const a=NUll://初始化的时候必须在定义的时候初始化 不可以先定义后初始化
错误 示范：
	int* const a=NULL;
	a=&d;
正确用法      int* const a=&d;



printf(（）)
%d %i   int
%c      char
%f      float
%lf     double
%s      字符串
%u      unsigned int
%o      八进制
%x 	  十六进制
%p      地址
%e      科学计数法
%g      输出小数，尾数后面的0会去掉 
4

printf和scanf
两者差别                printf 后面的参数直接将变量放进去就行
			          scanf后面的量必须是指针

运算符
      ＝ 赋值运算符
     ＋－*/%
/整除 ，只取整数
%取余，（常用于验证两个数是否整除）   只有整型非负的变量或者数据才能做取余操作

1..如果运算符两边有一个long double,运算结果就是double
2.如果运算符两边有一个double运算结果就是double 
3.float 如果运算符两边有一个float那计算结果就是float
4如果运算符两边有一个long int，计算结果就是long int
5. 若有运算符两边有一个unsigned int,计算结果就是unsigned int
6否则就是int

a＝a－b；     与a-=b 写法是一样的

＋＋   －－ 自加，自减
把变量本身加1或者减1；然后再保存到时变量本身中去
使用限制必须是整型变量才能使用＋＋    --
总结：
 1：＋＋i    先自加然后再进行其他运算
2：i＋＋     先把值拿出来后自加 

c语言的位运算    6个位运算符
针对的是二进制数
＆  按位与
｜按位或
^  异或
～取反
＜＜左移
＞＞右移
12


左移，将一个二进制数左移多少位，右边用0补齐
右移，将一个二进制数右移多少位，左边用0补齐
c=b<<2   b*4然后赋值给c


逻辑运算符
＆＆         逻辑与
｜｜         逻辑或       有一个为真则结果为真


三目运算符
？   ：
例：  （a>b）?a:b     如果a大于b，则结果为a， 否则结果为b



溢出
超出了表示范围
unsigned int=－2
如果一个整型变量被赋予的值超过了他的取值范围，那么就会发生溢出现角（也称之为回绕）
               无符号的整型变量回绕到0，重新开始
		有符号的整型变量回绕到最小的负值
		浮点类型没有回绕，如果说超出他的表示范围则会表示为inf（无穷大）


作业：
   使用三目运算符比较三个整数大小找出最大的那数输出！



条件判断语句
      if(条件) 条件判断语句
		if（条件）&&(条件)
			｛
                         需要执行的语句....
                        ｝						
                         如果满足条件，就执行大括号里面的内容 
		if（）
		｛
		语
		｝		
		else｛	
		语句		
		｝

if条件里面的值为0，则为假 ，非0，则为真；
		int a＝123
		if（a）
		｛
0
		  ｝


if语句在执行语句只有一条的时候可以省略大括号;
if里面最好不要只有一层嵌套，如果有多层嵌套，说明该换思路了！


案例：课堂练习
	从键盘输入一个年份
	判断是否为闰年
1：能被4整除不能被100整除
2:  能被400整除！


a=100
100=a 编译器会报错！


循环控制语句
	for（条件1；条件2；条件3）
        ｛
		语句
	｝
语句1：初始化语句 
语句2：循环条件判断语句（退出循环的条件判断）
语句3:循环调整语句 
          先执行初始化语句，执行条件判断语句（判断是否为真，如果条件为真，执行循环体内的内容）否则跳出循环执行完循环体内的内容以后会rntf


打印星号

＊
＊＊＊
＊＊＊＊＊
＊＊＊＊＊＊＊ 
：

素数
1 跟本身整除
找出100－1000之间的所有素数
 
使用用的知识点 if



三种循环语句：   for ; while  ;   do-while;



 for
for 循环首先使用的


ｂｒｅａｋ
break 语句是用来跳出循环体的（跳出for） 只能跳出一个循环体 继续 执行循环体外的语句 
continue语句，是用来略过循环体中剩余语句 ，直接进入 到下一次循环调整语句继续下一次循环

注意：break只能在循环体和switch case 中使用！ 




while循环
while 循环的语法结构
while(条件表达式)
｛
	语句
      。。。
｝
先判断条件表达式 如果为真 执行循环体内的语句
执行之后循环返回再次判断条件表达 式知道条件表达式为假为止继续执行循环体外的语句 


do-while语法结构
      do 
		{
		语句
		}while(条件表达式)；
自选进入循环体，然后判断条件表达式
如果为真 则执行后返回再一次执行循环体
执行完循环体之后，再一次判断
do-while 跟while的差别主要区别就是do-while中的循环体至少执行一次


for死循环的写法   for（；；）
						{}                           或者        for(;;);


while死循环      while(1);

开关语句
switch case
 switch(表达式)
 ｛
       case 1:
		 .........;
		break;
		case 2:
                ..........;
		break;
		default:
		break;
}
表达式必须有整型结果或者可以直接 转换成整型，一般为整型或者字符类型
       根据表达式的值和哪个case后面的值匹配判断从哪个case进入语句块执行
在写法上 如果为了达到特殊的效果 可以省略break 但是理论上是每个case后面必须跟上一个break否则 在进入 case后面语句之后还是会执行下面的标签定义的语句
default标签定义了一个缺省入口 如果上面的case都 没有相匹配的则进入default，default
类似于




课堂练习
写一个简单的计算器，实现加减乘除
要求从键盘输入数字以及符号，自动计算输出 结果；



作业：
1： 随便输入 一个很大的整数 
     使用程序来计算这个数的位数
2：查找素数 使用while方式来查找（要求使用continue）
3：给定一个百分之的分数，输出相应的等级
    90分以上的是A
    80－89 B
	70－79  C
	60－69   D	   
	60以下为E，要求 使用switch case
4打印图形
*
***
*****
*******
*****
***
*






getchar()  
从键盘获取一个字符





c语言允许用户自定义变量类型

枚举
         枚举是一种自己定义的类型
	需要使用到关键字enum
	使用方式：
	    enum 类型名｛值1，值2，值3，.....｝;
		大括号中称之为枚举常量
		默认初始化值 是从0开始依次递增，如果给枚举赋值的话，则从赋值之后的值，都是前一个值加1
   

    给类型名称起别名
	typedef enum color clr;
   
	定义 一个enum color 类型的变量
	clr b=BLUE;  //初始值为BLLUE
	

别名typedef
	声明一个指定类型的标识符
	把标识 符名儿改成你自己喜欢 的别名
	使用方式
		typedef int i;

缓冲区问题
	缓冲区有一个特征
		在输入缓冲区中，只有当其中的数据被清读走的时候，才能清除这个数据
	
		scanf（数据类型）和缓冲区的数据类型不一致的时候，它就无法读取数据，就会造成死循环！


键盘－>>键盘缓冲区-->>输入缓冲区－＞＞程序
程序－＞＞输出缓冲区－＞＞屏幕




数组
	聚合变量 能够保存一组数据（同类型的一组数据）
	数组的基本类型
					char
					int
					float
					double
	

	一维数组
	定义方式 ：
		int a［5］； ／／定义了一个整型的一维数组，这个数组名称为a，大小为5
		
		数组的初始化
		
	在c语言里面字符串实质上可以等同于字符数组
		char name［15］＝｛0｝；
		char＊ name＝“123456789”  ／／等号后面是字符串常量，     定义了一个字符类型的指针 它指向常量字符串"123456789" 第一个元素位置；		

只有字符数组可以用 %s 一次性打印出来

一维数组的名字
		一般数组名字是第一个元素的地址
		（数组首元素的地址）

课堂练习

从键盘输入一串数字，反向输出；

从键盘输入一个很大的数字，
程序功能是输出这个整数中重复的数字 以及数字重复的次数 

    

二维数组
int a[10][10]={0};



课堂练习
	使用二维数组打印一个5＊5 的方阵  ，用＊号表示!






printf("%d\n",a［0］)  等同于   printf("%d\n",*a)（数组名字是第一个元素的地址）
printf("%d\n",a［2］)  等同于   printf("%d\n",*(a+2))（指针＋地址＝它的值）




对数组使用sizeof运算符 注意事项
	sizeof(数组)=sizeof(数组的元素)＊元素的个数
	可以通过档sizeof来计算数组的大小
	数组的长度＝sizeof(数组)／sizeof(数组元素)


二维数组的指针打印方式
printf ("%d\n",*(*(b+1))+1))



结构体
	结构体是用户自定义的一种类型 一般  是把不同的类型的数据信息组织到一起共同描述一个事物！
		学生的属性	
			学号 int  no;
			名字  char name[15]   //字符数组
			性别   int  gender;
			学分   float score;	
		struct student{
							int no;
							char name[15];
							int gender;
							float score;
							}；
	
		typedef struct student stu;


	printf("学号：%d--名字：%s--性别：%d--学分：%g\n",b->no,a.name,a.gender,a.score);
	printf("学号：%d--名字：%s--性别：%d--学分：%g\n",b->no,(*b).name,(*b).gender,(*b).score);

		访问结构体的成员变量 都 是用取成员操作符  " . "   来引用结构变量的元素
		也可以用指向结构体的指针来调用结构体成员
		（＊p）.name;
		p->name;

计算结构体变量长度时，
		注意两点：
					1>.从下至下，第一个变量加上第二个变量的长度时，第一个必须是第二个的倍数，如果不是，则把第一个补到与4个字节的长度，然后再加第三个，也是这种规则；     （在linux下：总长度是与int对齐，不管有没有比它更长的，即使没有int在里面，还是与4的倍数对齐，在windows下，如果出现了double,则以double对齐，没有double.则以int对齐！）                                        
				       2＞. 全部变量加完后，总长度必须是最长变量的倍数，如果不是，则补齐！
					(这样是为了方便机算机快速寻址！)




联合体
	union





变量
  int main()  中的int是隐式声明，一切的未知类型C语言都看成是int类型
     在函数体外定义的变量是全局变量；或者说在文件里面定义的变量
			如果全局变量没有被初始化，系统默认初始值是0
			全局变量是公用的，它可以在任何地方使用；
             	局部变量 是在函数体内定义的或者说在循环体内定义的
		局部变量是在小范围内定义的变量出了范围就无法使用；

	现象：在一个函数里面不能同时出现两个同名的局部变量，即使是类型不一样也不可以，
					如果说，在一个文件 里面这义了一个全局变量 a又在函数里面定义了一个局部变量a，这样是不行的
  	结论：如果重名，局部变量会覆盖全局变量的值（使用的实际上是局部变量）。



头文件（ .h）的定义
＃ifndef _BIANLIANF_H_
#define _BIANLIANF_H_
int a=30;
#endif
这样做是防止头文件被 重复引用；


变量前面可加的关键字
	const    常量  
	static   静态变量       如果说没有初始化，则初始值系统默认为0	
				特点：
					静态局部变量会一直保持这个值（在一个），直到程序结束
					普通的局部变量在函数调用结束后空间就会被释放
			
 		创建静态局部变量的语句只会被调用一次，只能分配一次空间

函数
	int(函数返回值)  add（函数名称） （int a1,int b1）
	{
	return a1+b1;
	}





register(寄存器) 修饰变量－－寄存器变量
		cpu中的寄存器存取 速度非常快，所以如果想要把一个变量放到寄存器里面去，要可  以      使       用register关键字
		register只是一个请求（写了不一定会申请成功）
		由于cpu寄存器的个数是有限的，而且有很多的寄存器都是有特殊功能 的，所以使用register声明的变量不一定会被放到寄存器里面a


 
		volatile--修饰变量－－－不稳定变量
	特点：程序中每次使用变量就读取一次变量的值


外部变量
		文件a中定义了一个（全局）变量，在文件 b中需要使用的话，那a文件的变量对于b文件 来说 就是一个外部变量

		外部变量 的使用：需要使用一个关键字extern说明这个变量是在其他文件里面定义的全局变量
		需要在调用 外部变量 的文件里面ixtern int v;说明告诉编译器我的这个变量是引用 的外部变量！



各种变量 的作用域（就是使用范围 作用范围）和可见性
	1  局部变量   作用域和可见性只能是在声明的区域内使用
	2  静态局部变量 作用域为程序执行期间，可见性为声明它语句块
	3  全局变量
		作用域和可见性均为程序 执行期间
	4  静态全局变量
		作用域和可见性均为本文件 里面
	5  外部变量
		作用域和可见性均为程序期间
	6 常量
		作用域和可见性均为声明它的语句块内

变量 的作用范围规则
	局部优先（强龙不压地头蛇） 如果变量名有同名的现象，小范围的变量 优先使用（全局变量跟局部变量同名 使用的局部变量）
	全局变量和静态变量如果没有初始化 则会自动初始化为0  



函数 
函数定义
返回值类型 	 函数名（函数参数）
｛
	相应的语句
｝         
函数的参数可以是多个，也可以没有参数

int add（void）
｛
		
｝
函数参数
	在函数 定义 的时候跟在函数名后面的参数 叫做形式参数
	形参（可以是没有参数，也可以是多个参数，参数与参数之间要用，号隔开 ）
	第一个形参都 必须要有它的类型 
	实际 参数（实参）也就是在主函数 里面调用 自定义函数 的：时候 传入的参数
	使用需要注意，当实际 参数传入 的时候，是将实际参数的内容复制一份到形参里面去的，我们在函数 里面的所有操作实际上是对形参的操作！
	在自定义 函数 里面，操作的时候不要尝试返回 一个局部变量的地址
	如果说函数执行结束，就会释放函数里面的有变量的内容跟内存

练习：
 	判断素数
	程序功能 ：从键盘输入一个数字 ，来判断该数字是否为素数
				判断函数是否素数的功能封装到一个自定义的函数里面



函数的使用方式
		直接使用   函数名（）；

函数
	程序实例－－公司
	main函数－－老板
        函数－－员工

 		1  函数的返回 值类型必须return返回值类型一致
		2  如果说函数没有返回 值类型必须是void
		3 C语言中返回值的类型可应用省略，系统默认是int类型！
			如果说函数 的返回值和return的返回值不匹配的话，会导致编译错误
	

写一个函数（交换两个整形的值）
在main函数里面调用交换函数，再打印a，b的值！



函数的默认值
	本质上是在C＋＋下面实现的 使用g＋＋来进行编译
	函数默认值的设定方式 ，必须 是从右向左来给定默认值（右边没有默认值左边就绝对不能有）
	在使用默认值的函数 的时候，是从左向右写（可以省略右边的值但是不能省略左边只写右边 的值）



	C当中的字符串
		一种是使用字符数组来保存        
		字符串是默认以“\0”做结束；
		另一种是直接定义字符指针指向常量字符串
		字符串操作相关的函数 string.h
				


		//功能是拷贝一个字符串到另外一个字符串里面
		char ＊strcpy（char标字符串，const char *src 源字符串）；

		//功能是将两个字符串连接起来
		char *strcat(char *dest 目标字符串，const char ＊src 源字符串)；

	
		//拷贝字符串
		void *memcpy（void *dest 目标字符串，const void *src 源字符串，size_t n 拷贝多少个字节）；



		//填充指定字符
		void ＊memset（void ＊s 在第一个写地址，int c 指定相应字符，size_t n 多少个字节）


		//计算字符串的长度
		size_t strlen(const char *s)
		特性：利用字符串以\0结束的特性，计算长度的方式是在字符串里面去计算的时候，是遇到\0就结束，即strlen计算字符串长度不包括\0,    sizeof则包括\0
		size_t 默认以整形返回





带参数的主函数 
int main(int argc,char* argv[])
{
	printf("%d\n",argc);
	printf("%s\n",argv[0]);
	printf("%s\n",argv[1]);
	return 0;


段错误：是由于越界访问产生的！




		递归函数（调用自己的函数）
	写一个程序求阶乘（从键盘输入任意一个数求他的阶乘）
	递归函数实质上是自己调用自己的函数！
	注意：
	 		1  在写递归函数 的时候首先要确定它结束的条件；
			2  	


int atoi(const char *nptr);//功能是将字符串转换成整型
long atoi(const char *nptr)//将字符串转换成长整型

将整型转换成字符串
		//将字符串按照一定的格式写入到str
		int sprintf(char *str,const char *format,...)
		printf的功能是将字符写到我们屏幕
		int a=12;
	printf("")


课堂练习
		定义一个结构体学生－－名字，学号 ，年龄
		要求使用 主函数的参数  带入学生的三个数据
		注意进行转换
		输出



1	首先创建一个程序，定义一个整型变量打印整形变量的值！
2	整型数5，用float ,double，小数点后两位输出！
3	打印一个名字，年龄，工资（三个printf）!
	字符串初始化
	1 char name[10]="name";
	2     char name[10];
		   memset(name,'0',10)	或者 char name[10]={0};
	   	strcpy(name,"name");

4	





		
指针
	指针是一个特殊的变量 ，它的里面存储的值只能是地址（内存地址），

	指针的定义方式：	
	指针指向的类型*  指针名称
	例：int＊a；
	没有初始化的指针称之为野指针！

	指针 的初始化
		int＊ a＝NULL;	(这是叫空指针，不是野指针)
		int b＝3；
		a＝＆b；
	
	不要向空指针里写数据，会造 成段错误!
	但可以自己开辟一片空间（给指针开辟一片内存空间）！

	可以通过指针以它指向的变量直接进行操作！
	
	void *malloc(size_t size);   注意括号里面没有逗号，所以size_t size是针对一个东西，比如 4，（int大小就是4）
  (size_t是指某种类型，一律看成整形吧！)      ／／内存分配

      	申请一片size大小的内存空间，并返回该空间的地址，如果size为0，返回值为NULL;
	a＝（int＊）malloc(4);//强制类型转换！

	强制类型转换 
	例 ：char *a      把a 转换成int*的指针：    （int*）a






	当操作完以后需要释放内存空间（归还内存空间），如果在程序当中分配了很多内存空间但是没有释放的话就会造成内存溢出！
	释放内存：free(a);
	malloc与free一般配套使用！

	在使用分配内存的时候，使用malloc 实质上是在堆空间里面分配的（堆空间里面分配的内存需要自己手动去释放）
	普通的局部变量还有全局变量，以及函数参数都是由系统在栈里面分配的空间特点由系统分配以及释放，当程序结束的时候或者函数结束的时候由系统自己回收
	free函数只能释放有malloc 系列函数在堆里面分配的空间



	课堂练习
	struct stu{
			int a ;
			int b;
			char c[15];
			}
	1   定义一个float指针
	2  定义一个指向自定义类型的指针
		struct stu* b=NULL;
		b=(struct stu*)malloc(sizeof(struct stu));
	3  定义一个指针指向一个整型数组！（该数组有五个整型元素）（数组指针）
		（int*）a[5];//a是一个数组 有5个元素每个元素都 是int＊类型   ，整型指针数组
		int (*a)[5];//a 是一个指针，指向数组，数组指针
			




	二级指针：指向指针的指针；
	

	函数：
	int fun();函数声明；／／先声明后，函数的定义过程写在末尾都可以！
	int(*fun)();  //指向函数的指针－－函数指针	


	管理协堆区的相关操作
	void * malloc (size_t size);//申请一片内存空间
	void ＊ calloc (成员个数，size); //按照成员来分配内存空间，每个成员多少
	void ＊realloc（voidJ* ptr,size）; //扩大已有的内存空间
	void free (void * ptr); //释放由以上任何一个函数生成的内存空间
	void ＊memset (void*s,int ,size);//设置一片内存空间
	malloc calloc   realloc  free  memset		


	字符数组 char a[10];
	memset(a,'\0',10)
	数组越界
	内存越界
			以上两种情况都有可能产生段错误！
	int a[5];
	a[5]----非法访问！	




函数名称
	strcpy
	strchr      char *strchr(const char *s, int c);
	 在一个字符串中查找给定字符的第一个匹配位置,  返回值，如果说找到了就返回地址，没有找到返回NULL

	strcmp
	char *strchr(const char *s, int c);
	功能是将字符串进行比较
	返回值：1   如果比较的两个字符串s1＞s2，返回值＞0
			 2   如果说两个相等 返回值＝0
		根据asc值来进行比较

	strcpy与strcat最常考，必須掌握！
	

	strcat 连接两个字符串
	
	stricmp 大小写不敏感方式比较两个串
	int stricmp(char*,char*atr2)

	strncmp同strcmp只不过多出来size参数
	功能 是比较字符串前多少个字符
	
	strnset（与memset可以混合使用）
	将一个串中的所有字符都 设定为指定字符
	char* strnset(char* str,char ch, sixe_t n)
	
	strpbrk
	是在字符串中查找字符串
	
	strrchr
	在字符串中查找指定字符 的最后一个出现 的位置；
	
	strstr
	在一个字符串中查找 指定字符串第一次出现的位置 ；
	
	将字符串转换成相应类型的数
	strtod  strtof  strtold	strtol strtoll
	
	strupr
	将字符串中小写字母转换成大写字母！
	
	

	课堂练习
	将输入一个字符串，将小写全都变成大写！（不用函数）    (还要考虑数字，符号)

	char a[20];
	char* p=a;
	bzero(a,20）;  给a全部赋值为0；
	int len = strlen(a);
	while(*p)    //while 里面 0 不执行，1  为真则执行，而 ' \0 '  ,刚好就是0；就不      
                                                                   用写＊p！＝‘\0’

	if((*p>='a'&&(*p)<='z'))    //则判定为小写
	(*p) = (*P)-('a'-'A');
	p++;
	




I/O 控制
	控制台的I/O

		scanf   从键盘输入
		printf  从键盘输出
		getchar   从键盘获取一个字符（没有参数）
		putchar   输出一个字符  （不会直接给你换行），只能放字符，如果输入的是整数，直接
															     通  过ASC码输出字符
		gets    从键盘获取一个字符串
					char *gets(char *s);
		puts 		输出一个字符串(默认会自动换行):

	

	字符串的I/O
		sprintf
		sscanf （“123456“，”%s“，buf）;
			将“123456”以%s的形式存放到时buf中去
	

	
	文件的I/O
	1   打开文件  fopen
		FIlE *fopen(const char *path,//路径
						const char *mode); //打开的模式       这种形式表示这个位置放
																	的是字符串
		

		返回值：返回的是一个文件 指针
		如果成功则返回文件 的地址，失败返回NULL;		
		－r 		以只读的方式打开文件 ，该文件必须存在
		－r+		以可读可写的方式打开文件 ，文件必须是存在的
		－w			打开只写文件 ，如果文件 存在把文件内容 清空变成大小为0，如果 文件不存在则
					创建文件
		－w+		打开文件（可读可写）文件存在文件 把内容清空大小变成0，不存在就创建 文件 
		－a      以追加的方式打开只写文件 ，如果文件存在就会把数据追加至文件尾，不存在就
					创建文件 
		－a＋    以追加的方式打开可读可写文件 ，如果文件存在就会把数据追加至文件尾，不
					存在    就创建文件 
		
	
		int fclose(FILE *fp);//关闭文件 
		int fgetc(FILE *stream);	//从文件里面读取一个字符；
		char *fgets(char *s,int size,FILE *stream);
				从文件里面读取一个字符串
		fgetc/fputc  向文件读／写一个字符
		fgets 从文件读取一行（把换行符作为字符的一部分）
		fputs向文件输入一行数据不会加上换行符
	
		int fputs(const char *s,  //你要写入的字符串
						FILE*stream);  //文件指针；

	
	
		 size_t  fread(void  *ptr,       //内存地址用来存储读取出来的数据
							size_t size, 		//元素大小
							size_t nmemb,		// 元素的个数
						   FILE *stream);		//文件
						返回值：一般成功返回成功读取的数据的个数错误返回 0 

       size_t fwrite(const void *ptr,  你需要写入到文件中的字符串
       					（可以是保存字符串的变量 ，或者是直接字符串）
							size_t  size,
					      size_t nmemb, 
							FILE *stream);


		课堂练习：：
		首先创建一个文件往文件里面写两次数据要求最后数据正常
		首先写入名字，学号
		第二次写入年龄，再写入性别
		可以使用中文，但是要求两次写入的数据不出现混乱；
				

		
		写一个程序创建一个文件
		往这个文件里面写入一个学生信息（使用结构体）的内容再写一个程序读取文件里面的信息然后保存到结构体里面打印结构体！
	
		
		




	当函数参数前面带const说明我们的这个参数传递到函数里面之后是不希望被更改的，也就是说该参数是能用于计算不能修改它的值！


	标准输出文件 	stdout
	标准输入文件 	stdin
	标准错误文件	stderr
	fprintf		将相关内容输出到文件
	fscanf      从文件里面读取内容
	fprintf(fp,"%d",a);
		将a的值按照第二个参数 里面的格式 输出 到文件 这中
	fscanf（）
	        从文件 中按照第二个参数的格式 读取数据保存到变量b当中
	fprintf(stdout,"1234564");将变量值输出 到输出设备行，stdout代表 的输出设备
	 fscanf(stdin, "%s%d%g")	
		


	fseek
		int fseek (FILE *stream,  //文件的指针
					  long offset,  //移动多少
						int whence);//从哪开始
		whence
			deek_SET,//从文件 的开头
			seek_CUR，//当前位置
			SEEK＿END，  //文件末尾的位置
		fseek(fp,12,SEEK_SET);//把文件指针从文件开头的位置往后移动12字节；
		fseek（fp,-12,seek_end）;



	课堂练习：
	      在文件夹里面建立一个文件 1. .cxx
		程序1：	使用fopen打开文件（选项必须是r＋）；往文件里面写入一个数据（一个人的信息）
		程序 2：同样使用fopen打开文件选项r＋；往文件里面写一个人的数据，要求不能覆盖掉程
				序1写的数据；




排序:
	算法： 冒泡排序
			  最原始，最慢
			  操作过程：从下标为0的位置开始，依次将它和后面的元素做比较
	   练习：将这个排序的算法封装到一个函数里面
	   		 在主函数里面调用函数实现排序
			  
			  
			  
		   插入排序
		   		工作原理：在一个有序的的数据序列当中要求在这个民经排好
		   				 的数据列中插入一个数！（两个数互换位置，
		   				 最后依次由大到小；）
		   
		   
		   
		   选择排序
				从数据中选择最小的与第一个进行交换
				第二次从剩余的数据里面找到最小的元素与第二个进行交换；
				
				
				
		   快速排序
		   		基于冒泡排序的改进
		   		排序过程：通过一趟排序将数据分成两半，
		   				 其中一部分要比另外一部分要小，
		   				 然后在按照上面的部分依次进行操作！
		   				 
		   				 第一步：找一个任意的点为参照物；
		   				 	将所有比它小的都放到左边，比它大的都放到
		   				 	右边（相当于把数组拆分成了两个）；
		   				 第二步：实质上是对接执行第一步操作，直到全部
		   				 	都有序为止；
		   				 	使用递归；	
		   				 
		   				 
		   

综合练习：
	1：首先创建一个空链表
	2：从文件 里面读取相应的数据 将数据保存到链表之中
	3：从键盘输入相应的账号密码 然后在链表里面去查找看密码是否匹配，如果
		说匹配成功就找印登陆成功，否则打印密码错误请重新输入
	模块功能是模拟用户登录的一个过程

实现的第一个步骤：需要构建一个文件 .dat文件
				使用技术文件操作，文件里面写一个结构体

			.










		





























	


















































		



















































































   

             

                 






























































